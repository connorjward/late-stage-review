\section{Background}

In this chapter we review: existing software abstractions for mesh computations, common strategies for optimising performance, and mesh-specific optimisations.

\subsection{Existing software abstractions}

\subsection{Stencil languages}

Given the ubiquity of stencil operations in simulations, a number of libraries exist providing convenient interfaces for stencil applications.

% they are largely all inspired by the following pieces of info:
% - a mesh can be considered as sets of entities
% - one loops over a set, collects adjacent data, then calls some local kernel
% - the local kernel may be written in the same language as the stencil language, but it needn't be

Ebb, Simit and Liszt follow the approach of providing a domain-specific language for the expression of stencil problems...
They all provide high performance execution on GPUs as well as CPUs.

% i don't think simit works on MPI

OP2 is another approach~\cite{mudaligeOP2ActiveLibrary2012,mudaligeDesignInitialPerformance2013}.
Rather than using a domain-specific language, OP2 provides a simple API to the user for specifying the problem.
The key entities in the OP2 data model are: sets, data on sets, mappings between sets, and operations applied over these sets.
Having provided these inputs, the OP2 compiler is then called and transforms to source code to a high performance implementation of the traversal for a specific architecture.

% then PyOP2
% describe libCEED - main benefit is that it is fast.

% it is noteworthy that Ebb, Simit, Liszt have custom implementations of unstructured meshes.
% whereas (Py)OP2 and libCEED have an abstraction that does not specifically include a mesh.
% the latter is favourable as one can reuse existing solutions to other mesh problems like
% refinement, adaptivity, I/O, decomposition...
% however, lack of topological information can make code unreadable, hard to write as
% topological info is lost, e.g. composability is not really possible.

% this leads very nicely into discussion of DMPlex
% note: we don't have a nice solution to orientations yet - but no one does

Another library for the application of stencil operations, specifically high-order matrix-free kernels for the \gls{fem}, is libCEED.
% libceed - actually offloaded to PETSc for element restriction (the bit PyOP2 does)
% it's nice that libCEED and PyOP2 use DMPlex as the burden of other mesh operations (e.g. distribution, I/O, refinement) are very non-trivial

PyOP2 is a domain-specific language for expressing computations over unstructured meshes.
It is the direct precursor, and inspiration for, \projectname.

It distinguishes itself from OP2, a library depending on the same abstractions, by using run-time code generation instead of static analysis and transformation of the source code.

PyOP2's mesh abstraction is formed out of the following main components:

% \begin{itemize}
%   \item \mintinline{python}{set}
% \end{itemize}

In PyOP2, data is defined on \textit{sets} and these are related to one another using \textit{mappings}.
Importantly, this abstraction does not contain any concept of the underlying mesh and instead all of the required information is encoded in the maps.

  Computations over the mesh are expressed as the execution of some local kernel over all entities of some iteration set via a construct called a parallel loop, or \textit{parloop}.
  The kernel is written using Loopy, a library for expressing array-based computations in a platform-generic language~\cite{klocknerLooPyTransformationbased2014}.
  This intermediate representation allows for interplay between the local kernels enabling optimisations such as inter-element vectorisation~\cite{sunStudyVectorizationMatrixfree2020}.

  At present, PyOP2 only works on distributed memory, CPU-only systems (although some work has been done to permit execution on GPUs~\cite{fenics2021-kulkarni}).
  During the execution of a parloop, each rank works independently on some partition of the mesh.
  To avoid excessive communication between ranks, each rank has a narrow \textit{halo} region that overlaps with neighbouring ranks that is executed redundantly.
  The halos are split into \textit{owned}, \textit{exec}, and \textit{non-exec} regions to indicate the data's origin and the communication direction between the neighbouring processes.


% Liszt, Simit - notably associates data information with topological entities

\subsubsection{Mesh representations}

In software, a mesh is typically represented by a collection of sets of entities (e.g. cells or faces), coupled with adjacency relations between these sets.
Possible abstractions capturing this behaviour include databases (ebb, moab) or hypergraphs (simit).
In this work we focus on DMPlex, the unstructured mesh abstraction used in PETSc.
In contrast with Ebb, Simit or Liszt, DMPlex is a more general purpose mesh abstraction and so has a more substantial feature set.z

In DMPlex, the mesh is represented as a \textit{CW-complex}, an object from algebraic topology that describes some topological space.
In such a complex, all topological entities (e.g. cells, vertices) are simply referred to as \textit{points} and the connectivity of the mesh can be expressed as the edges of a \gls{dag} with the vertices being the points of the mesh.
More specifically, the points and relations form a \gls{poset} such that the mesh can be visualised using a Hasse diagram (Figure~\ref{fig:hasse_diagram}).

It is important to note that DMPlex works for arbitrary dimension.

\begin{figure}
  \begin{subfigure}{0.45\textwidth}
    \begin{tikzpicture}
      \draw (0,2) -- (2,0);
      \draw (0,2) -- (2,4);
      \draw (2,0) -- (2,4);
      \draw (2,0) -- (4,2);
      \draw (2,4) -- (4,2);

      \node[at={(1,2)}, xshift=.2cm] {1};
      \node[at={(3,2)}, xshift=-.2cm] {2};
      \node[at={(0,2)}, xshift=-.2cm] {3};
      \node[at={(2,4)}, yshift=.2cm] {4};
      \node[at={(2,0)}, yshift=-.2cm] {5};
      \node[at={(4,2)}, xshift=.2cm] {6};
      \node[at={(1,1)}, xshift=-.2cm, yshift=-.2cm] {7};
      \node[at={(1,3)}, xshift=-.2cm, yshift=.2cm] {8};
      \node[at={(2,2)}, xshift=-.2cm] {9};
      \node[at={(3,3)}, xshift=.2cm, yshift=.2cm] {10};
      \node[at={(3,1)}, xshift=.2cm, yshift=-.2cm] {11};
    \end{tikzpicture}
  \end{subfigure}
  %
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
    \end{tikzpicture}
  \end{subfigure}

  \caption{...}
  \label{fig:hasse_diagram}
\end{figure}

% stencil operations next - closure, star, etc

\begin{figure}
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 7,9;
      \draw [dashed] (1) circle [radius=15pt];
    \end{tikzpicture}
    \caption{$cone(1)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 1,2;
      \draw [dashed] (9) circle [radius=15pt];
    \end{tikzpicture}
    \caption{$supp(9)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 1,7,3,5,9;
    \end{tikzpicture}
    \caption{$cl(1)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 4,10,2,1,8;
    \end{tikzpicture}
    \caption{$star(4)$}
  \end{subfigure}

  \caption{...}
  \label{fig:plex_restrictions}
\end{figure}


Stencil queries are natural to express at this level.
For instance, the classical finite element request of ``give me all of the \glspl{dof} that have local support" is simply expressed as the closure of a given cell.
Another example useful for finite volume calculations: ``what are my neighbouring cells?" is supp(cone(c)).
One can also do clever patch things.


\subsubsection{Orienting degrees-of-freedom}

One significant challenge stencil applications face when applied to \glspl{pde} is on agreeing on a consistent orientation of the \glspl{dof} for shared entities.
% introduce ``reference'' as a term
%Note that we use the term ``reference'' here to mean ``the canonical arrangement of \glspl{dof} that is expected by the local kernel''.

To demonstrate the issue, consider the \gls{dof} arrangements shown in Figure~\ref{fig:orient}.
Figures~\ref{fig:orient_basic_ref} and~\ref{fig:orient_vector_ref} show the reference \gls{dof} arrangements for an arbitrary space on triangles, with scalar or vector \glspl{dof} on the edges respectively.
Likewise, Figures~\ref{fig:orient_basic_flip} and~\ref{fig:orient_vector_flip} show the resulting \gls{dof} arrangements for the same spaces but with one of the edges flipped.
In either flipped case, were the \glspl{dof} to be naively packed into a local temporary and passed to a local kernel, the results would be incorrect as the \glspl{dof} would be passed in in the wrong order.

For many cell types, the orientation problem can be avoided through renumbering the mesh such that adjacent entities agree on the orientations of any shared facets or edges.
In particular this has been shown to work for simplices~\cite{rognesEfficientAssemblyMathrmdiv2010}, as well as quadrilaterals and (some) hexes~\cite{agelekOrientingEdgesUnstructured2017,homolyaParallelEdgeOrientation2016}.
\dots
Hexes are annoying because they cannot be oriented in parallel and some meshes (e.g. Mo(..)bius strip) are not orientable.
But. We want them for tokamaks (cite).

However, for more complicated cell types with more complex symmetry groups (e.g. hexes or pyramids), the issue of orientation cannot be avoided by a simple renumbering and \gls{dof} transformations are needed to be able to collect the \glspl{dof} in a suitable reference order.
For scalar-valued \glspl{dof}, one simply needs to permute the order in which \glspl{dof} are loaded into the local temporary.
This can easily be done in advance and be encapsulated by, for example, a PyOP2 \mintinline{python}{Map}.
This approach is insufficient for vector-valued \glspl{dof} though as components may still be pointing in the wrong direction.
This is demonstrated in Figure~\ref{fig:orient_vector_flip} where one can see that simply permuting the \glspl{dof} on the flipped edge would not be enough.
One also needs to multiply the values by $-1$ in order to get the vectors pointing in the right direction.
The situation is further complicated in 3D where one could have two tangent vectors per \gls{dof} on each face, requiring the application of a $2\times2$ rotation matrix to reach consensus.

The general solution to orienting \glspl{dof} for stencil application is therefore as follows:
First, one loads the (permuted) \glspl{dof} associated with a particular entity, along with a bitarray encoding the entity's orientation.
Then, one can apply appropriate transformations to the loaded \glspl{dof} such that they can be correctly passed through to the local kernel.
This is the approach used by Basix~\cite{scroggsConstructionArbitraryOrder2021,scroggsBasixRuntimeFinite2022}, part of the FEniCSx finite element software suite~\cite{}.
However, to our knowledge, this is not performed by any existing stencil library.

\begin{figure}
  \centering
    \centering
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        \filldraw [draw=black,fill=red!50] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_basic_ref}
    \end{subfigure}
    %
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v2}
        \tkzDefShiftPoint[v0](60:4){v1}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        \filldraw [draw=black,fill=red!50] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_basic_flip}
    \end{subfigure}

    \vspace{1em}

    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        % arrows
        \tkzDefShiftPoint[e0d0](-90:.6){e0d0v}
        \draw[-stealth,draw=red!80,line width=1] (e0d0) -- (e0d0v);
        \tkzDefShiftPoint[e0d1](-90:.6){e0d1v}
        \draw[-stealth,draw=red!80,line width=1] (e0d1) -- (e0d1v);
        \tkzDefShiftPoint[e1d0](30:.6){e1d0v}
        \draw[-stealth,draw=red!80,line width=1] (e1d0) -- (e1d0v);
        \tkzDefShiftPoint[e1d1](30:.6){e1d1v}
        \draw[-stealth,draw=red!80,line width=1] (e1d1) -- (e1d1v);
        \tkzDefShiftPoint[e2d0](150:.6){e2d0v}
        \draw[-stealth,draw=red!80,line width=1] (e2d0) -- (e2d0v);
        \tkzDefShiftPoint[e2d1](150:.6){e2d1v}
        \draw[-stealth,draw=red!80,line width=1] (e2d1) -- (e2d1v);

        % filled bits
        \filldraw [draw=black,fill=red!80,line width=.7] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_vector_ref}
    \end{subfigure}
    %
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v2,v1)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        % arrows
        \tkzDefShiftPoint[e0d0](-90:.6){e0d0v}
        \draw[-stealth,draw=red!80,line width=1] (e0d0) -- (e0d0v);
        \tkzDefShiftPoint[e0d1](-90:.6){e0d1v}
        \draw[-stealth,draw=red!80,line width=1] (e0d1) -- (e0d1v);
        \tkzDefShiftPoint[e1d0](210:.6){e1d0v}
        \draw[-stealth,draw=red!80,line width=1] (e1d0) -- (e1d0v);
        \tkzDefShiftPoint[e1d1](210:.6){e1d1v}
        \draw[-stealth,draw=red!80,line width=1] (e1d1) -- (e1d1v);
        \tkzDefShiftPoint[e2d0](150:.6){e2d0v}
        \draw[-stealth,draw=red!80,line width=1] (e2d0) -- (e2d0v);
        \tkzDefShiftPoint[e2d1](150:.6){e2d1v}
        \draw[-stealth,draw=red!80,line width=1] (e2d1) -- (e2d1v);

        \filldraw [draw=black,fill=red!80] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!80] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!80] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$b$};
        \filldraw [draw=black,fill=red!80] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$a$};
        \filldraw [draw=black,fill=red!80] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!80] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_vector_flip}
    \end{subfigure}

    \caption{}
    \label{fig:orient}
\end{figure}

\subsection{Methods for performance optimisation}

\subsubsection{Roofline model}

\begin{figure}
  \input{./figures/roofline.pgf}
\end{figure}

\subsection{Optimisations for mesh computations}

% all about data layout

% extrusion only matters 20% (or working set)
