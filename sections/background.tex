\section{Background}

In this chapter we review: existing software abstractions for mesh computations, common strategies for optimising performance, and mesh-specific optimisations.

\subsection{Existing software abstractions}

\subsection{Stencil languages}

Given the ubiquity of stencil operations in simulations, a number of libraries exist providing convenient interfaces for stencil applications.

% they are largely all inspired by the following pieces of info:
% - a mesh can be considered as sets of entities
% - one loops over a set, collects adjacent data, then calls some local kernel
% - the local kernel may be written in the same language as the stencil language, but it needn't be

Ebb, Simit and Liszt follow the approach of providing a domain-specific language for the expression of stencil problems...
They all provide high performance execution on GPUs as well as CPUs.

% i don't think simit works on MPI

OP2 is another approach~\cite{mudaligeOP2ActiveLibrary2012,mudaligeDesignInitialPerformance2013}.
Rather than using a domain-specific language, OP2 provides a simple API to the user for specifying the problem.
The key entities in the OP2 data model are: sets, data on sets, mappings between sets, and operations applied over these sets.
Having provided these inputs, the OP2 compiler is then called and transforms to source code to a high performance implementation of the traversal for a specific architecture.

% then PyOP2
% describe libCEED - main benefit is that it is fast.

% it is noteworthy that Ebb, Simit, Liszt have custom implementations of unstructured meshes.
% whereas (Py)OP2 and libCEED have an abstraction that does not specifically include a mesh.
% the latter is favourable as one can reuse existing solutions to other mesh problems like
% refinement, adaptivity, I/O, decomposition...
% however, lack of topological information can make code unreadable, hard to write as
% topological info is lost, e.g. composability is not really possible.

% this leads very nicely into discussion of DMPlex
% note: we don't have a nice solution to orientations yet - but no one does

Another library for the application of stencil operations, specifically high-order matrix-free kernels for the \gls{fem}, is libCEED.
% libceed - actually offloaded to PETSc for element restriction (the bit PyOP2 does)
% it's nice that libCEED and PyOP2 use DMPlex as the burden of other mesh operations (e.g. distribution, I/O, refinement) are very non-trivial

PyOP2 is a domain-specific language for expressing computations over unstructured meshes.
It is the direct precursor, and inspiration for, \projectname.

It distinguishes itself from OP2, a library depending on the same abstractions, by using run-time code generation instead of static analysis and transformation of the source code.

PyOP2's mesh abstraction is formed out of the following main components:

% \begin{itemize}
%   \item \mintinline{python}{set}
% \end{itemize}

In PyOP2, data is defined on \textit{sets} and these are related to one another using \textit{mappings}.
Importantly, this abstraction does not contain any concept of the underlying mesh and instead all of the required information is encoded in the maps.

  Computations over the mesh are expressed as the execution of some local kernel over all entities of some iteration set via a construct called a parallel loop, or \textit{parloop}.
  The kernel is written using Loopy, a library for expressing array-based computations in a platform-generic language~\cite{klocknerLooPyTransformationbased2014}.
  This intermediate representation allows for interplay between the local kernels enabling optimisations such as inter-element vectorisation~\cite{sunStudyVectorizationMatrixfree2020}.

  At present, PyOP2 only works on distributed memory, CPU-only systems (although some work has been done to permit execution on GPUs~\cite{fenics2021-kulkarni}).
  During the execution of a parloop, each rank works independently on some partition of the mesh.
  To avoid excessive communication between ranks, each rank has a narrow \textit{halo} region that overlaps with neighbouring ranks that is executed redundantly.
  The halos are split into \textit{owned}, \textit{exec}, and \textit{non-exec} regions to indicate the data's origin and the communication direction between the neighbouring processes.


% Liszt, Simit - notably associates data information with topological entities

\subsubsection{Mesh representations}

In software, a mesh is typically represented by a collection of sets of entities (e.g. cells or faces), coupled with adjacency relations between these sets.
Possible abstractions capturing this behaviour include databases (ebb, moab) or hypergraphs (simit).
In this work we focus on DMPlex, the unstructured mesh abstraction used in PETSc.
In contrast with Ebb, Simit or Liszt, DMPlex is a more general purpose mesh abstraction and so has a more substantial feature set.z

In DMPlex, the mesh is represented as a \textit{CW-complex}, an object from algebraic topology that describes some topological space.
In such a complex, all topological entities (e.g. cells, vertices) are simply referred to as \textit{points} and the connectivity of the mesh can be expressed as the edges of a \gls{dag} with the vertices being the points of the mesh.
More specifically, the points and relations form a \gls{poset} such that the mesh can be visualised using a Hasse diagram (Figure~\ref{fig:hasse_diagram}).

It is important to note that DMPlex works for arbitrary dimension.

\begin{figure}
  \begin{subfigure}{0.45\textwidth}
    \begin{tikzpicture}
      \draw (0,2) -- (2,0);
      \draw (0,2) -- (2,4);
      \draw (2,0) -- (2,4);
      \draw (2,0) -- (4,2);
      \draw (2,4) -- (4,2);

      \node[at={(1,2)}, xshift=.2cm] {1};
      \node[at={(3,2)}, xshift=-.2cm] {2};
      \node[at={(0,2)}, xshift=-.2cm] {3};
      \node[at={(2,4)}, yshift=.2cm] {4};
      \node[at={(2,0)}, yshift=-.2cm] {5};
      \node[at={(4,2)}, xshift=.2cm] {6};
      \node[at={(1,1)}, xshift=-.2cm, yshift=-.2cm] {7};
      \node[at={(1,3)}, xshift=-.2cm, yshift=.2cm] {8};
      \node[at={(2,2)}, xshift=-.2cm] {9};
      \node[at={(3,3)}, xshift=.2cm, yshift=.2cm] {10};
      \node[at={(3,1)}, xshift=.2cm, yshift=-.2cm] {11};
    \end{tikzpicture}
  \end{subfigure}
  %
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
    \end{tikzpicture}
  \end{subfigure}

  \caption{...}
  \label{fig:hasse_diagram}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 7,9;
      \draw [dashed] (1) circle [radius=15pt];
    \end{tikzpicture}
    \caption{$cone(1)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 1,2;
      \draw [dashed] (9) circle [radius=15pt];
    \end{tikzpicture}
    \caption{$supp(9)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 1,7,3,5,9;
    \end{tikzpicture}
    \caption{$cl(1)$}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \basichasse
      \drawpolygon 4,10,2,1,8;
    \end{tikzpicture}
    \caption{$star(4)$}
  \end{subfigure}

  \caption{...}
  \label{fig:plex_restrictions}
\end{figure}


Stencil queries are natural to express at this level.
For instance, the classical finite element request of ``give me all of the \glspl{dof} that have local support" is simply expressed as the closure of a given cell.
Another example useful for finite volume calculations: ``what are my neighbouring cells?" is supp(cone(c)).
One can also do clever patch things.


\subsubsection{Orienting degrees-of-freedom}

One significant challenge stencil applications face when applied to \glspl{pde} is on agreeing on a consistent orientation of the \glspl{dof} for shared entities.
% introduce ``reference'' as a term
%Note that we use the term ``reference'' here to mean ``the canonical arrangement of \glspl{dof} that is expected by the local kernel''.

To demonstrate the issue, consider the \gls{dof} arrangements shown in Figure~\ref{fig:orient}.
Figures~\ref{fig:orient_basic_ref} and~\ref{fig:orient_vector_ref} show the reference \gls{dof} arrangements for an arbitrary space on triangles, with scalar or vector \glspl{dof} on the edges respectively.
Likewise, Figures~\ref{fig:orient_basic_flip} and~\ref{fig:orient_vector_flip} show the resulting \gls{dof} arrangements for the same spaces but with one of the edges flipped.
In either flipped case, were the \glspl{dof} to be naively packed into a local temporary and passed to a local kernel, the results would be incorrect as the \glspl{dof} would be passed in in the wrong order.

For many cell types, the orientation problem can be avoided through renumbering the mesh such that adjacent entities agree on the orientations of any shared facets or edges.
In particular this has been shown to work for simplices~\cite{rognesEfficientAssemblyMathrmdiv2010}, as well as quadrilaterals and (some) hexes~\cite{agelekOrientingEdgesUnstructured2017,homolyaParallelEdgeOrientation2016}.
\dots
Hexes are annoying because they cannot be oriented in parallel and some meshes (e.g. Mo(..)bius strip) are not orientable.
But. We want them for tokamaks (cite).

However, for more complicated cell types with more complex symmetry groups (e.g. hexes or pyramids), the issue of orientation cannot be avoided by a simple renumbering and \gls{dof} transformations are needed to be able to collect the \glspl{dof} in a suitable reference order.
For scalar-valued \glspl{dof}, one simply needs to permute the order in which \glspl{dof} are loaded into the local temporary.
This can easily be done in advance and be encapsulated by, for example, a PyOP2 \mintinline{python}{Map}.
This approach is insufficient for vector-valued \glspl{dof} though as components may still be pointing in the wrong direction.
This is demonstrated in Figure~\ref{fig:orient_vector_flip} where one can see that simply permuting the \glspl{dof} on the flipped edge would not be enough.
One also needs to multiply the values by $-1$ in order to get the vectors pointing in the right direction.
The situation is further complicated in 3D where one could have two tangent vectors per \gls{dof} on each face, requiring the application of a $2\times2$ rotation matrix to reach consensus.

The general solution to orienting \glspl{dof} for stencil application is therefore as follows:
First, one loads the (permuted) \glspl{dof} associated with a particular entity, along with a bitarray encoding the entity's orientation.
Then, one can apply appropriate transformations to the loaded \glspl{dof} such that they can be correctly passed through to the local kernel.
This is the approach used by Basix~\cite{scroggsConstructionArbitraryOrder2021,scroggsBasixRuntimeFinite2022}, part of the FEniCSx finite element software suite~\cite{}.
However, to our knowledge, this is not performed by any existing stencil library.

\begin{figure}
  \centering
    \centering
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        \filldraw [draw=black,fill=red!50] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_basic_ref}
    \end{subfigure}
    %
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v2}
        \tkzDefShiftPoint[v0](60:4){v1}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        \filldraw [draw=black,fill=red!50] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!50] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!50] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_basic_flip}
    \end{subfigure}

    \vspace{1em}

    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v1,v2)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        % arrows
        \tkzDefShiftPoint[e0d0](-90:.6){e0d0v}
        \draw[-stealth,draw=red!80,line width=1] (e0d0) -- (e0d0v);
        \tkzDefShiftPoint[e0d1](-90:.6){e0d1v}
        \draw[-stealth,draw=red!80,line width=1] (e0d1) -- (e0d1v);
        \tkzDefShiftPoint[e1d0](30:.6){e1d0v}
        \draw[-stealth,draw=red!80,line width=1] (e1d0) -- (e1d0v);
        \tkzDefShiftPoint[e1d1](30:.6){e1d1v}
        \draw[-stealth,draw=red!80,line width=1] (e1d1) -- (e1d1v);
        \tkzDefShiftPoint[e2d0](150:.6){e2d0v}
        \draw[-stealth,draw=red!80,line width=1] (e2d0) -- (e2d0v);
        \tkzDefShiftPoint[e2d1](150:.6){e2d1v}
        \draw[-stealth,draw=red!80,line width=1] (e2d1) -- (e2d1v);

        % filled bits
        \filldraw [draw=black,fill=red!80,line width=.7] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$b$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!80,line width=.7] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_vector_ref}
    \end{subfigure}
    %
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        % setup
        \tkzSetUpStyle[
          postaction=decorate,
          decoration={markings, mark=at position .5 with {\arrow[thick]{#1}} }
        ]{myarrow}

        % triangle
        \tkzDefPoint(0,0){v0}
        \tkzDefShiftPoint[v0](0:4){v1}
        \tkzDefShiftPoint[v0](60:4){v2}
        \tkzDrawSegment[myarrow=stealth](v0,v1)
        \tkzDrawSegment[myarrow=stealth](v2,v1)
        \tkzDrawSegment[myarrow=stealth](v0,v2)

        % edge dofs
        \tkzDefBarycentricPoint(v0=2,v1=1) \tkzGetPoint{e0d0}
        \tkzDefBarycentricPoint(v0=1,v1=2) \tkzGetPoint{e0d1}
        \tkzDefBarycentricPoint(v1=2,v2=1) \tkzGetPoint{e1d0}
        \tkzDefBarycentricPoint(v1=1,v2=2) \tkzGetPoint{e1d1}
        \tkzDefBarycentricPoint(v0=2,v2=1) \tkzGetPoint{e2d0}
        \tkzDefBarycentricPoint(v0=1,v2=2) \tkzGetPoint{e2d1}

        % arrows
        \tkzDefShiftPoint[e0d0](-90:.6){e0d0v}
        \draw[-stealth,draw=red!80,line width=1] (e0d0) -- (e0d0v);
        \tkzDefShiftPoint[e0d1](-90:.6){e0d1v}
        \draw[-stealth,draw=red!80,line width=1] (e0d1) -- (e0d1v);
        \tkzDefShiftPoint[e1d0](210:.6){e1d0v}
        \draw[-stealth,draw=red!80,line width=1] (e1d0) -- (e1d0v);
        \tkzDefShiftPoint[e1d1](210:.6){e1d1v}
        \draw[-stealth,draw=red!80,line width=1] (e1d1) -- (e1d1v);
        \tkzDefShiftPoint[e2d0](150:.6){e2d0v}
        \draw[-stealth,draw=red!80,line width=1] (e2d0) -- (e2d0v);
        \tkzDefShiftPoint[e2d1](150:.6){e2d1v}
        \draw[-stealth,draw=red!80,line width=1] (e2d1) -- (e2d1v);

        \filldraw [draw=black,fill=red!80] (e0d0) circle [radius=7pt];
        \node at (e0d0) {$a$};
        \filldraw [draw=black,fill=red!80] (e0d1) circle [radius=7pt];
        \node at (e0d1) {$b$};
        \filldraw [draw=black,fill=red!80] (e1d0) circle [radius=7pt];
        \node at (e1d0) {$b$};
        \filldraw [draw=black,fill=red!80] (e1d1) circle [radius=7pt];
        \node at (e1d1) {$a$};
        \filldraw [draw=black,fill=red!80] (e2d0) circle [radius=7pt];
        \node at (e2d0) {$a$};
        \filldraw [draw=black,fill=red!80] (e2d1) circle [radius=7pt];
        \node at (e2d1) {$b$};
      \end{tikzpicture}
      \caption{}
      \label{fig:orient_vector_flip}
    \end{subfigure}

    \caption{}
    \label{fig:orient}
\end{figure}

\subsection{Methods for performance optimisation}

In this section we review some of the common bottlenecks in massively parallel simulation codes, and describe some general ways for quantifying and improving performance.
In particular we focus on challenges for maximising parallel efficiency and the importance of the roofline model for choosing appropriate optimisations.
The aim is to motivate design choices made in \pyop3.

\subsubsection{Optimisation methodology}

Premature optimisation is a classic trap software developers fall into when they attempt to accelerate their codes.
It is surprisingly easy to find oneself making assumptions about the locations and causes of bottlenecks, and then wasting a considerable amount of time on optimising code that only constitutes a small fraction of the overall wall-clock time.
To avoid this scenario, developers should follow the steps below:

\begin{enumerate}
  \item
    \textbf{Find a realistic problem to try and accelerate.}

    Performance optimisation is often guided by toy problems that are simple to write and debug.
    Such problems, though, may end up having significantly different performance characteristics from a realistic simulation that a user would actually run.
    This can lead to premature optimisation as the wrong hotspots will be targeted.
    As a relevant example, one could work hard to optimise data movement for the application of low-order matrix-free stencils since the code will be memory-bound (see section~\ref{sec:background_perf_flops}) and so data movement would be the predominant cost.
    However, matrix-free methods are usually only applied at high-order~\cite{brownPerformancePortableSolid2022}, at which point the code will be compute-bound and the hotspots will be different.
  \item
    \textbf{Identify the hotspots.}
    \dots
    % flamegraph
  \item
    \textbf{Create a performance model.}
    \dots
    % roofline, think about message passing if needed
  \item
    \textbf{Optimise the code.}
    \dots
    % prioritise algorithmic changes over low-level optimisations as these can change convergence stuff
    % ref TAS spectrum?
  \item
    \textbf{Repeat?}
    \dots
    % are we at the fundamental limit of the machine?
    % is our scaling 'good enough'
\end{enumerate}

\subsubsection{Achieving parallel efficiency}
\label{sec:background_perf_efficiency}

In order to run massive simulations, codes must be able to exploit the massive amounts of parallelism afforded to them by modern supercomputers.
With the building of ever larger and more parallel machines (especially since we are at the ``dawn of exascale''), this is becoming both more important to get right and more challenging to do so.

To quantify a code's effectiveness in parallel, one typically measures its \textit{parallel efficiency} under either \textit{strong-} or \textit{weak-scaling}:

\begin{paragraph}{Strong-scaling}
A strong-scaling investigation would solve the same problem but on an increasing number of processors and measure the time-to-solution.
Perfect efficiency (unity) would be achieved if the time-to-solution on $p$ processors was $p$ times smaller than the time-to-solution for a single process.
If strong-scaling efficiency is poor, this suggests that there are sizeable portions of the code that are getting run in serial on each process, rather than being divided up.
A code would be considered to have `good' strong-scaling if it retained high efficiency (e.g. 80\%) at small problem sizes (e.g. 5000 \glspl{dof} per process for \gls{fem}).
\end{paragraph}

\begin{paragraph}{Weak-scaling}
Weak-scaling differs from strong-scaling by, rather than measuring the decrease in time-to-solution for a problem of fixed size, recording the time-to-solution for a range of problem sizes where the size of the problem scales linearly with the number of processors.
In this case, perfect efficiency is achieved if the time-to-solution remains fixed.
If a code has poor weak-scaling, this suggests that there are algorithmic problems regarding how the problem is distributed among processors.
For example, a parallel algorithm that required frequent all-to-all broadcast messages would have poor weak-scaling because this would increase in cost with the number of processors.
For a code to have `good' weak-scaling, it would need to have a high efficiency (e.g. 80\%) even when run on very large clusters.
\end{paragraph}

Taken together, these two metrics provide a relatively good indicator as to the suitability of a code for running on massively parallel computers, which is naturally essential for simulation codes to be effective.
More informative measures of performance that take into account things such as convergence rates also exist~\cite{changComparativeStudyFinite2018}, but we eschew such measures here because they fall under the remit of the design of the stencil itself, rather than the stencil \textit{iteration}, which is the focus for this work.

\subsubsection{Maximising floating-point throughput}
\label{sec:background_perf_flops}

\begin{figure}
  \input{./figures/roofline.pgf}
  % \begin{tikzpicture}
  %   \begin{loglogaxis}[
  %     xlabel={xlabel},
  %     ylabel={ylabel},
  %   ]
  %     % left intercept is (height-c)/m
  %
  %     % \node (
  %
  %     % scalar throughput
  %     \addplot coordinates {(2, 1) (100, 1)}; 
  %     % vector throughput
  %     \addplot coordinates {(2, 8) (100, 8)}; 
  %
  %     % cache bandwidth
  %     \addplot coordinates {(0, 1) ({(8-1)/2}, 8))};
  %
  %     % main memory bandwidth
  %     \addplot coordinates {};
  %   \end{loglogaxis}
  % \end{tikzpicture}
\end{figure}



\subsection{Optimisations for mesh computations}

% all about data layout

% extruded mesh diagram
\begin{tikzpicture}[scale=1.5]
  % start with 2 base triangles (4 vertices)
  \tkzDefPoint(0,.5){v0v0}
  \tkzDefPoint(2,0){v1v0}
  \tkzDefPoint(1.2,1){v2v0} % this one is invisible
  \tkzDefPoint(3.2,.5){v3v0}

  % now figure out the extruded points (3 columns)
  \tkzDefShiftPoint[v0v0](90:1){v0v1}
  \tkzDefShiftPoint[v0v0](90:2){v0v2}
  \tkzDefShiftPoint[v0v0](90:3){v0v3}

  \tkzDefShiftPoint[v1v0](90:1){v1v1}
  \tkzDefShiftPoint[v1v0](90:2){v1v2}
  \tkzDefShiftPoint[v1v0](90:3){v1v3}

  \tkzDefShiftPoint[v2v0](90:1){v2v1}
  \tkzDefShiftPoint[v2v0](90:2){v2v2}
  \tkzDefShiftPoint[v2v0](90:3){v2v3}

  \tkzDefShiftPoint[v3v0](90:1){v3v1}
  \tkzDefShiftPoint[v3v0](90:2){v3v2}
  \tkzDefShiftPoint[v3v0](90:3){v3v3}

  % base
  \tkzDrawSegments[red!80,densely dashed,line width=1](v0v0,v2v0 v1v0,v2v0 v2v0,v3v0)

  % draw the vertical lines (v2 is invisible)
  \tkzDrawSegments[line width=1](v0v0,v0v1 v0v1,v0v2 v0v2,v0v3)
  \tkzDrawSegments[line width=1](v1v0,v1v1 v1v1,v1v2 v1v2,v1v3)
  \tkzDrawSegments[line width=1](v3v0,v3v1 v3v1,v3v2 v3v2,v3v3)

  % horizontal (bottom is red)
  \tkzDrawSegments[red!80,line width=1](v0v0,v1v0 v1v0,v3v0)
  \tkzDrawSegments[line width=1](v0v1,v1v1 v1v1,v3v1)
  \tkzDrawSegments[line width=1](v0v2,v1v2 v1v2,v3v2)
  \tkzDrawSegments[line width=1](v0v3,v1v3 v1v3,v3v3)

  % top
  \tkzDrawSegments[line width=1](v0v3,v2v3 v2v3,v3v3)
  \tkzDrawSegment[line width=1](v1v3,v2v3)

  \tkzDrawPoints[red!80](v0v0,v1v0,v2v0,v3v0)
  \tkzDrawPoints(v0v1,v0v2,v0v3,v1v1,v1v2,v1v3,v2v3,v3v1,v3v2,v3v3)
\end{tikzpicture}

% extrusion only matters 20% (or working set)

% use halos/ghost cells for good parallel efficiency
