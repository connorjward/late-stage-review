\section{Implementation}

% pyop3 is inspired by Simit in that we have a mesh representation that lowers to an indexed tensor 
% representation for computing

% should support Gpu, inter-element vectorisation

\subsection{Mesh operations}
% present the interface

\subsection{Hierarchical data layout}

\pyop3 employs a novel hierarchical data layout.
It was inspired by considering what the data layouts of mesh data actually look like.
As a simple example, consider the data layout for a typically unstructured mesh with *some nodes and some DoFs per node* (see Figure X - include a triangle too).

%In \pyop2, we flatten early to a DataSet == Set + dim
% can only guarantee fixed loop bounds for the innermost `dim` - for codegen.

% now show extruded - demos the need for a hierarchy as flattening clearly loses information.
% state that this lets us do cool composition?

% data layout example
\begin{tikzpicture}[y=-1cm]
  \fill[lightgray] (0,0) rectangle(7,1);
  \filldraw[draw=black, fill=white] (0.5,0) rectangle (1.5,1);
  \filldraw[draw=black, fill=white] (1.5,0) rectangle (2.5,1);
  \filldraw[draw=black, fill=white] (2.5,0) rectangle (3.5,1);
  \filldraw[draw=black, fill=white] (3.5,0) rectangle (4.5,1);
  \node[at={(1,.5)}, ptlabel] {$c_0$};
  \node[at={(2,.5)}, ptlabel] {$v_1$};
  \node[at={(3,.5)}, ptlabel] {$c_4$};
  \node[at={(4,.5)}, ptlabel] {$v_8$};
  \draw (0,0) -- (7,0);
  \draw (0,1) -- (7,1);

  \begin{scope}[yshift=-2cm]
    \filldraw[draw=black, fill=white] (2,0) rectangle (3,1);
    \filldraw[draw=black, fill=white] (3,0) rectangle (4,1);
    \node[at={(2.5,.5)}, ptlabel] {$d_0$};
    \node[at={(3.5,.5)}, ptlabel] {$d_1$};
    \draw (2,0) rectangle (4,1);

    \draw (2.5,-1) -- (2,0);
    \draw (3.5,-1) -- (4,0);
  \end{scope}

\end{tikzpicture}

\subsection{Parallel design}

% based on/lifted from PyOP2
% ghost/halo values for overlaps
% clever layout means we can exchange core, then owned, interleaving communication
% PETSc Mat for parallel matrices

\begin{figure}
  \begin{tikzpicture}
    % define styles
    \tkzSetUpStyle[draw=white,line width=5]{cell}
    \tkzSetUpStyle[line width=2,shorten >=.15cm,shorten <=.15cm]{edge}

    \tkzSetUpStyle[cell,fill=red!50]{p1cell}
    \tkzSetUpStyle[edge,draw=red!80]{p1edge}
    \tkzSetUpStyle[draw=red!80,fill=red!80]{p1vert}
    \tkzSetUpStyle[cell,fill=blue!50]{p2cell}
    \tkzSetUpStyle[edge,draw=blue!80]{p2edge}
    \tkzSetUpStyle[draw=blue!80,fill=blue!80]{p2vert}

    \tkzSetUpStyle[densely dashed,shorten >=.1cm,shorten <=.1cm,line width=.5]{connector}

    % process 1
    \begin{scope}
      % define nodes
      \tkzDefPoint(0,0){p1v0}
      \tkzDefPoint(.1,1.1){p1v1}
      \tkzDefPoint(0,1.9){p1v2}
      \tkzDefPoint(.2,3.1){p1v3}
      \tkzDefPoint(1.1,0){p1v4}
      \tkzDefPoint(1,1){p1v5}
      \tkzDefPoint(.9,2){p1v6}
      \tkzDefPoint(1,3){p1v7}
      \tkzDefPoint(2,0){p1v8}
      \tkzDefPoint(2.1,1){p1v9}
      \tkzDefPoint(2,2.1){p1v10}
      \tkzDefPoint(1.9,3.2){p1v11}
      \tkzDefPoint(3,-.1){p1v12}
      \tkzDefPoint(3.1,.9){p1v13}
      \tkzDefPoint(3,2.1){p1v14}
      \tkzDefPoint(3.1,3.1){p1v15}

      % cells
      \tkzDrawPolygon[p1cell](p1v0,p1v1,p1v4)
      \tkzDrawPolygon[p1cell](p1v1,p1v4,p1v5)
      \tkzDrawPolygon[p1cell](p1v1,p1v5,p1v6)
      \tkzDrawPolygon[p1cell](p1v1,p1v2,p1v6)
      \tkzDrawPolygon[p1cell](p1v2,p1v3,p1v6)
      \tkzDrawPolygon[p1cell](p1v3,p1v6,p1v7)
      \tkzDrawPolygon[p1cell](p1v4,p1v8,p1v9)
      \tkzDrawPolygon[p1cell](p1v4,p1v5,p1v9)
      \tkzDrawPolygon[p1cell](p1v5,p1v9,p1v10)
      \tkzDrawPolygon[p1cell](p1v5,p1v6,p1v10)
      \tkzDrawPolygon[p1cell](p1v6,p1v7,p1v10)
      \tkzDrawPolygon[p1cell](p1v7,p1v10,p1v11)
      \tkzDrawPolygon[p1cell](p1v8,p1v9,p1v12)
      \tkzDrawPolygon[p2cell](p1v9,p1v12,p1v13)
      \tkzDrawPolygon[p2cell](p1v9,p1v13,p1v14)
      \tkzDrawPolygon[p1cell](p1v9,p1v10,p1v14)
      \tkzDrawPolygon[p2cell](p1v10,p1v14,p1v15)
      \tkzDrawPolygon[p1cell](p1v10,p1v11,p1v15)

      % edges
      \tkzDrawSegments[p1edge](p1v0,p1v1 p1v1,p1v2 p1v2,p1v3)
      \tkzDrawSegments[p1edge](p1v4,p1v5 p1v5,p1v6 p1v6,p1v7)
      \tkzDrawSegments[p1edge](p1v8,p1v9 p1v9,p1v10 p1v10,p1v11)
      \tkzDrawSegments[p2edge](p1v12,p1v13 p1v13,p1v14 p1v14,p1v15)

      \tkzDrawSegments[p1edge](p1v0,p1v4 p1v4,p1v8)
      \tkzDrawSegments[p1edge](p1v1,p1v5 p1v5,p1v9)
      \tkzDrawSegments[p1edge](p1v2,p1v6 p1v6,p1v10)
      \tkzDrawSegments[p1edge](p1v3,p1v7 p1v7,p1v11 p1v11,p1v15)
      \tkzDrawSegments[p2edge](p1v8,p1v12 p1v9,p1v13 p1v10,p1v14)

      \tkzDrawSegments[p1edge](p1v1,p1v4 p1v1,p1v6 p1v3,p1v6)
      \tkzDrawSegments[p1edge](p1v4,p1v9 p1v5,p1v10 p1v7,p1v10)
      \tkzDrawSegments[p2edge](p1v9,p1v12 p1v9,p1v14 p1v10,p1v15)  % mimics process 2

      % vertices
      \tkzDrawPoints[p1vert](p1v0,p1v1,p1v2,p1v3,p1v4,p1v5,p1v6,p1v7,p1v8,p1v9,p1v10,p1v11)
      \tkzDrawPoints[p2vert](p1v12,p1v13,p1v14,p1v15)

      % debugging
      % \tkzLabelPoints[anchor=south,font=\tiny](p1v0,p1v1,p1v2,p1v3,p1v4,p1v5,p1v6,p1v7,p1v8,p1v9,p1v10,p1v11,p1v12,p1v13,p1v14,p1v15)

      % draw a sample patch
      % source: https://tex.stackexchange.com/questions/356564/macro-for-rounded-polygon-around-some-nodes
      % \def\drawpatch#1,#2;{
        % \begin{pgfonlayer}{background}
          % \filldraw[line width=25,join=round](#1.center)foreach\A in{#2}{--(\A.center)}--cycle;
          % \filldraw[line width=24,join=round,fill=black!20,fill opacity=.2](#1.center)foreach\A in{#2}{--(\A.center)}--cycle;
        % \end{pgfonlayer}
      % }
      % \drawpatch p1v5,p1v7,p1v15,p1v13;
    \end{scope}

    % process 2
    \begin{scope}[xshift=5cm]
      % define nodes
      \tkzDefPoint(0,0){p2v0}
      \tkzDefPoint(0,1){p2v1}
      \tkzDefPoint(0,2){p2v2}
      \tkzDefPoint(0,3){p2v3}
      \tkzDefPoint(1,0){p2v4}
      \tkzDefPoint(1,1){p2v5}
      \tkzDefPoint(1,2){p2v6}
      \tkzDefPoint(1,3){p2v7}
      \tkzDefPoint(2,0){p2v8}
      \tkzDefPoint(2,1){p2v9}
      \tkzDefPoint(2,2){p2v10}
      \tkzDefPoint(2,3){p2v11}
      \tkzDefPoint(3,0){p2v12}
      \tkzDefPoint(3,1){p2v13}
      \tkzDefPoint(3,2){p2v14}
      \tkzDefPoint(3,3){p2v15}

      % cells
      \tkzDrawPolygon[p1cell](p2v0,p2v1,p2v4)
      \tkzDrawPolygon[p2cell](p2v1,p2v4,p2v5)
      \tkzDrawPolygon[p2cell](p2v1,p2v5,p2v6)
      \tkzDrawPolygon[p1cell](p2v1,p2v2,p2v6)
      \tkzDrawPolygon[p2cell](p2v2,p2v6,p2v7)
      \tkzDrawPolygon[p1cell](p2v2,p2v3,p2v7)
      \tkzDrawPolygon[p2cell](p2v4,p2v5,p2v8)
      \tkzDrawPolygon[p2cell](p2v5,p2v8,p2v9)
      \tkzDrawPolygon[p2cell](p2v5,p2v6,p2v9)
      \tkzDrawPolygon[p2cell](p2v6,p2v9,p2v10)
      \tkzDrawPolygon[p2cell](p2v6,p2v10,p2v11)
      \tkzDrawPolygon[p2cell](p2v6,p2v7,p2v11)
      \tkzDrawPolygon[p2cell](p2v8,p2v9,p2v12)
      \tkzDrawPolygon[p2cell](p2v9,p2v12,p2v13)
      \tkzDrawPolygon[p2cell](p2v9,p2v10,p2v13)
      \tkzDrawPolygon[p2cell](p2v10,p2v13,p2v14)
      \tkzDrawPolygon[p2cell](p2v10,p2v14,p2v15)
      \tkzDrawPolygon[p2cell](p2v10,p2v11,p2v15)

      % edges
      \tkzDrawSegments[p1edge](p2v0,p2v1 p2v1,p2v2 p2v2,p2v3)
      \tkzDrawSegments[p2edge](p2v4,p2v5 p2v5,p2v6 p2v6,p2v7)
      \tkzDrawSegments[p2edge](p2v8,p2v9 p2v9,p2v10 p2v10,p2v11)
      \tkzDrawSegments[p2edge](p2v12,p2v13 p2v13,p2v14 p2v14,p2v15)

      \tkzDrawSegments[p2edge](p2v0,p2v4 p2v4,p2v8 p2v8,p2v12)
      \tkzDrawSegments[p2edge](p2v1,p2v5 p2v5,p2v9 p2v9,p2v13)
      \tkzDrawSegments[p2edge](p2v2,p2v6 p2v6,p2v10 p2v10,p2v14)
      \tkzDrawSegments[p2edge](p2v7,p2v11 p2v11,p2v15)
      \tkzDrawSegments[p1edge](p2v3,p2v7)

      \tkzDrawSegments[p2edge](p2v1,p2v4 p2v1,p2v6 p2v2,p2v7)
      \tkzDrawSegments[p2edge](p2v5,p2v8)
      \tkzDrawSegments[p2edge](p2v6,p2v9)
      \tkzDrawSegments[p2edge](p2v6,p2v11)
      \tkzDrawSegments[p2edge](p2v9,p2v12 p2v10,p2v13 p2v10,p2v15)

      % vertices
      \tkzDrawPoints[p1vert](p2v0,p2v1,p2v2,p2v3)
      \tkzDrawPoints[p2vert](p2v4,p2v5,p2v6,p2v7,p2v8,p2v9,p2v10,p2v11,p2v12,p2v13,p2v14,p2v15)

      % debugging
      % \tkzLabelPoints[anchor=south,font=\tiny](p2v0,p2v1,p2v2,p2v3,p2v4,p2v5,p2v6,p2v7,p2v8,p2v9,p2v10,p2v11,p2v12,p2v13,p2v14,p2v15)
    \end{scope}

    % connect (sample of) equivalent points
    \draw [-{stealth},connector] (p1v11) to [bend left=45] (p2v3);
    \draw [{stealth}-,connector] (p1v15) to [bend left=45] (p2v7);
    \draw [-{stealth},connector] (p1v8) to [bend right=45] (p2v0);
    \draw [{stealth}-,connector] (p1v12) to [bend right=45] (p2v4);
  \end{tikzpicture}
  \caption{}
  \label{fig:halos}
\end{figure}

% PETSc is scalable (cite?)
% PyOP2 (via Firedrake assembly) has good weak scalability

% also strong-scaling (but shown otherwise)
% key is to minimise amount of Python in the hot loops via judicious caching, persistent objects and expanded codegen

% use DG advection as an example - caching and persistent objects can be shown to be key
% but now things like halo exchanges for valid halos (i.e. noops) have non-trivial cost -> move out of Python to the generated code.

\vspace{1em}
