\section{Implementation}

% pyop3 is inspired by Simit in that we have a mesh representation that lowers to an indexed tensor 
% representation for computing

% should support Gpu, inter-element vectorisation

\subsection{Mesh operations}
% present the interface

\subsection{Hierarchical data layout}

\pyop3 employs a novel hierarchical data layout.
It was inspired by considering what the data layouts of mesh data actually look like.
As a simple example, consider the data layout for a typically unstructured mesh with *some nodes and some DoFs per node* (see Figure X - include a triangle too).

%In \pyop2, we flatten early to a DataSet == Set + dim
% can only guarantee fixed loop bounds for the innermost `dim` - for codegen.

% now show extruded - demos the need for a hierarchy as flattening clearly loses information.
% state that this lets us do cool composition?

% data layout example
\begin{tikzpicture}[y=-1cm]
  \fill[lightgray] (0,0) rectangle(7,1);
  \filldraw[draw=black, fill=white] (0.5,0) rectangle (1.5,1);
  \filldraw[draw=black, fill=white] (1.5,0) rectangle (2.5,1);
  \filldraw[draw=black, fill=white] (2.5,0) rectangle (3.5,1);
  \filldraw[draw=black, fill=white] (3.5,0) rectangle (4.5,1);
  \node[at={(1,.5)}, ptlabel] {$c_0$};
  \node[at={(2,.5)}, ptlabel] {$v_1$};
  \node[at={(3,.5)}, ptlabel] {$c_4$};
  \node[at={(4,.5)}, ptlabel] {$v_8$};
  \draw (0,0) -- (7,0);
  \draw (0,1) -- (7,1);

  \begin{scope}[yshift=-2cm]
    \filldraw[draw=black, fill=white] (2,0) rectangle (3,1);
    \filldraw[draw=black, fill=white] (3,0) rectangle (4,1);
    \node[at={(2.5,.5)}, ptlabel] {$d_0$};
    \node[at={(3.5,.5)}, ptlabel] {$d_1$};
    \draw (2,0) rectangle (4,1);

    \draw (2.5,-1) -- (2,0);
    \draw (3.5,-1) -- (4,0);
  \end{scope}

\end{tikzpicture}

\subsection{Parallel design}

% based on/lifted from PyOP2
% ghost/halo values for overlaps
% clever layout means we can exchange core, then owned, interleaving communication
% PETSc Mat for parallel matrices

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=1.3]
    % define styles
    \tkzSetUpStyle[draw=white,line width=5]{cell}
    \tkzSetUpStyle[line width=2,shorten >=.2cm,shorten <=.2cm]{edge}

    \tkzSetUpStyle[cell,fill=red!50]{p1cell}
    \tkzSetUpStyle[edge,draw=red!80]{p1edge}
    \tkzSetUpStyle[draw=red!80,fill=red!80]{p1vert}
    \tkzSetUpStyle[cell,fill=blue!50]{p2cell}
    \tkzSetUpStyle[edge,draw=blue!80]{p2edge}
    \tkzSetUpStyle[draw=blue!80,fill=blue!80]{p2vert}

    \tkzSetUpStyle[densely dashed,shorten >=.1cm,shorten <=.1cm,line width=.5]{connector}

    % process 1
    \begin{scope}
      % define nodes
      \tkzDefPoint(0,0){p1v0}
      \tkzDefPoint(.1,1.1){p1v1}
      \tkzDefPoint(0,1.9){p1v2}
      \tkzDefPoint(.2,3.1){p1v3}
      \tkzDefPoint(1.1,0){p1v4}
      \tkzDefPoint(1,1){p1v5}
      \tkzDefPoint(.9,2){p1v6}
      \tkzDefPoint(1,3){p1v7}
      \tkzDefPoint(2,0){p1v8}
      \tkzDefPoint(2.1,1){p1v9}
      \tkzDefPoint(2,2.1){p1v10}
      \tkzDefPoint(1.9,3.2){p1v11}
      \tkzDefPoint(3,-.1){p1v12}
      \tkzDefPoint(3.1,.9){p1v13}
      \tkzDefPoint(3,2.1){p1v14}
      \tkzDefPoint(3.1,3.1){p1v15}

      % cells
      \tkzDrawPolygon[p1cell](p1v0,p1v1,p1v4)
      \tkzDrawPolygon[p1cell](p1v1,p1v4,p1v5)
      \tkzDrawPolygon[p1cell](p1v1,p1v5,p1v6)
      \tkzDrawPolygon[p1cell](p1v1,p1v2,p1v6)
      \tkzDrawPolygon[p1cell](p1v2,p1v3,p1v6)
      \tkzDrawPolygon[p1cell](p1v3,p1v6,p1v7)
      \tkzDrawPolygon[p1cell](p1v4,p1v8,p1v9)
      \tkzDrawPolygon[p1cell](p1v4,p1v5,p1v9)
      \tkzDrawPolygon[p1cell](p1v5,p1v9,p1v10)
      \tkzDrawPolygon[p1cell](p1v5,p1v6,p1v10)
      \tkzDrawPolygon[p1cell](p1v6,p1v7,p1v10)
      \tkzDrawPolygon[p1cell](p1v7,p1v10,p1v11)
      \tkzDrawPolygon[p1cell](p1v8,p1v9,p1v12)
      \tkzDrawPolygon[p2cell](p1v9,p1v12,p1v13)
      \tkzDrawPolygon[p2cell](p1v9,p1v13,p1v14)
      \tkzDrawPolygon[p1cell](p1v9,p1v10,p1v14)
      \tkzDrawPolygon[p2cell](p1v10,p1v14,p1v15)
      \tkzDrawPolygon[p1cell](p1v10,p1v11,p1v15)

      % edges
      \tkzDrawSegments[p1edge](p1v4,p1v5 p1v5,p1v6 p1v6,p1v7)
      \tkzDrawSegments[p1edge](p1v8,p1v9 p1v9,p1v10 p1v10,p1v11)
      \tkzDrawSegments[p2edge,opacity=.5](p1v12,p1v13 p1v13,p1v14 p1v14,p1v15)

      \tkzDrawSegments[p1edge](p1v0,p1v4 p1v4,p1v8)
      \tkzDrawSegments[p1edge](p1v1,p1v5 p1v5,p1v9)
      \tkzDrawSegments[p1edge](p1v2,p1v6 p1v6,p1v10)
      \tkzDrawSegments[p1edge](p1v3,p1v7 p1v7,p1v11 p1v11,p1v15)
      \tkzDrawSegments[p2edge,opacity=.5](p1v8,p1v12 p1v9,p1v13 p1v10,p1v14)

      \tkzDrawSegments[p1edge](p1v1,p1v4 p1v1,p1v6 p1v3,p1v6)
      \tkzDrawSegments[p1edge](p1v4,p1v9 p1v5,p1v10 p1v7,p1v10)
      \tkzDrawSegments[p2edge,opacity=.5](p1v9,p1v12 p1v9,p1v14 p1v10,p1v15)  % mimics process 2

      % vertices
      % \tkzDrawPoints[p1vert](p1v0,p1v1,p1v2,p1v3,p1v4,p1v5,p1v6,p1v7)  % core
      \tkzDrawPoints[p1vert,size=5](p1v4,p1v5,p1v6,p1v7)  % core
      \tkzDrawPoints[p1vert,diamond,size=6](p1v8,p1v9,p1v10,p1v11)  % owned
      \tkzDrawPoints[p2vert,diamond,opacity=.5,size=6](p1v12,p1v13,p1v14,p1v15)

      % debugging
      % \tkzLabelPoints[anchor=south,font=\tiny](p1v0,p1v1,p1v2,p1v3,p1v4,p1v5,p1v6,p1v7,p1v8,p1v9,p1v10,p1v11,p1v12,p1v13,p1v14,p1v15)

      % draw a sample patch
      \tkzDefShiftPoint[p1v7](-.2,.2){p1v7patch}
      \tkzDefShiftPoint[p1v11](0,.2){p1v11patch}
      \tkzDefShiftPoint[p1v15](.2,.2){p1v15patch}
      \tkzDefShiftPoint[p1v14](.2,-.1){p1v14patch}
      \tkzDefShiftPoint[p1v9](.1,-.2){p1v9patch}
      \tkzDefShiftPoint[p1v5](-.2,-.2){p1v5patch}
      \tkzDefShiftPoint[p1v6](-.2,0){p1v6patch}
      \filldraw[draw=black,fill=black,fill opacity=.1,rounded corners=2]
      % \filldraw[draw=none,fill=blue,fill opacity=.4,rounded corners=2]
      % \filldraw[pattern={Hatch[distance=3mm,angle=45]},draw=black,rounded corners=2]
        (p1v7patch) -- (p1v11patch) -- (p1v15patch) -- (p1v14patch) -- (p1v9patch) --
        (p1v5patch) -- (p1v6patch) -- cycle;
      \draw [densely dashed] (p1v10) circle [radius=5pt];

      % label "core" and "owned"
      \node (p1core) [inner sep=0pt,xshift=-20pt,yshift=20pt] at (p1v7) {\footnotesize core};
      \node (p1owned) [inner sep=0pt,xshift=-10pt,yshift=20pt] at (p1v11) {\footnotesize owned};
      \draw [-{stealth},shorten >=4pt,shorten <=2pt] (p1core.south) -- (p1v7.north);
      \draw [-{stealth},shorten >=4pt,shorten <=2pt] (p1owned.south) -- (p1v11.north);
    \end{scope}

    % process 2
    \begin{scope}[xshift=5cm]
      % define nodes
      \tkzDefPoint(0,0){p2v0}
      \tkzDefPoint(.1,1){p2v1}
      \tkzDefPoint(0,2.1){p2v2}
      \tkzDefPoint(-.1,3.2){p2v3}
      \tkzDefPoint(1,-.1){p2v4}
      \tkzDefPoint(1.1,.9){p2v5}
      \tkzDefPoint(1,2.1){p2v6}
      \tkzDefPoint(1.1,3.1){p2v7}
      \tkzDefPoint(2,-.1){p2v8}
      \tkzDefPoint(2,1.1){p2v9}
      \tkzDefPoint(2.1,2){p2v10}
      \tkzDefPoint(2,2.9){p2v11}
      \tkzDefPoint(3,.1){p2v12}
      \tkzDefPoint(3.1,1){p2v13}
      \tkzDefPoint(2.9,2){p2v14}
      \tkzDefPoint(2.9,3.1){p2v15}

      % cells
      \tkzDrawPolygon[p1cell,opacity=.5](p2v0,p2v1,p2v4)
      \tkzDrawPolygon[p2cell](p2v1,p2v4,p2v5)
      \tkzDrawPolygon[p2cell](p2v1,p2v5,p2v6)
      \tkzDrawPolygon[p1cell,opacity=.5](p2v1,p2v2,p2v6)
      \tkzDrawPolygon[p2cell](p2v2,p2v6,p2v7)
      \tkzDrawPolygon[p1cell,opacity=.5](p2v2,p2v3,p2v7)
      \tkzDrawPolygon[p2cell](p2v4,p2v5,p2v8)
      \tkzDrawPolygon[p2cell](p2v5,p2v8,p2v9)
      \tkzDrawPolygon[p2cell](p2v5,p2v6,p2v9)
      \tkzDrawPolygon[p2cell](p2v6,p2v9,p2v10)
      \tkzDrawPolygon[p2cell](p2v6,p2v10,p2v11)
      \tkzDrawPolygon[p2cell](p2v6,p2v7,p2v11)
      \tkzDrawPolygon[p2cell](p2v8,p2v9,p2v12)
      \tkzDrawPolygon[p2cell](p2v9,p2v12,p2v13)
      \tkzDrawPolygon[p2cell](p2v9,p2v10,p2v13)
      \tkzDrawPolygon[p2cell](p2v10,p2v13,p2v14)
      \tkzDrawPolygon[p2cell](p2v10,p2v14,p2v15)
      \tkzDrawPolygon[p2cell](p2v10,p2v11,p2v15)

      % edges
      \tkzDrawSegments[p1edge,opacity=.5](p2v0,p2v1 p2v1,p2v2 p2v2,p2v3)
      \tkzDrawSegments[p2edge](p2v4,p2v5 p2v5,p2v6 p2v6,p2v7)
      \tkzDrawSegments[p2edge](p2v8,p2v9 p2v9,p2v10 p2v10,p2v11)

      \tkzDrawSegments[p2edge](p2v0,p2v4 p2v4,p2v8 p2v8,p2v12)
      \tkzDrawSegments[p2edge](p2v1,p2v5 p2v5,p2v9 p2v9,p2v13)
      \tkzDrawSegments[p2edge](p2v2,p2v6 p2v6,p2v10 p2v10,p2v14)
      \tkzDrawSegments[p2edge](p2v7,p2v11 p2v11,p2v15)
      \tkzDrawSegments[p1edge,opacity=.5](p2v3,p2v7)

      \tkzDrawSegments[p2edge](p2v1,p2v4 p2v1,p2v6 p2v2,p2v7)
      \tkzDrawSegments[p2edge](p2v5,p2v8)
      \tkzDrawSegments[p2edge](p2v6,p2v9)
      \tkzDrawSegments[p2edge](p2v6,p2v11)
      \tkzDrawSegments[p2edge](p2v9,p2v12 p2v10,p2v13 p2v10,p2v15)

      % vertices
      \tkzDrawPoints[p2vert,size=5](p2v8,p2v9,p2v10,p2v11)  % core
      \tkzDrawPoints[p2vert,diamond,size=6](p2v4,p2v5,p2v6,p2v7)  % owned
      \tkzDrawPoints[p1vert,diamond,size=6,opacity=.5](p2v0,p2v1,p2v2,p2v3)  % halo

      % label "core" and "owned"
      \node (p2core) [inner sep=0pt,xshift=15pt,yshift=20pt] at (p2v11) {\footnotesize core};
      \node (p2owned) [inner sep=0pt,xshift=10pt,yshift=20pt] at (p2v7) {\footnotesize owned};
      \draw [-{stealth},shorten >=4pt,shorten <=2pt] (p2core.south) -- (p2v11.north);
      \draw [-{stealth},shorten >=4pt,shorten <=2pt] (p2owned.south) -- (p2v7.north);

      % debugging
      % \tkzLabelPoints[anchor=south,font=\tiny](p2v0,p2v1,p2v2,p2v3,p2v4,p2v5,p2v6,p2v7,p2v8,p2v9,p2v10,p2v11,p2v12,p2v13,p2v14,p2v15)
    \end{scope}

    % connect (sample of) equivalent points
    \draw [-{stealth},connector,shorten >=4pt,shorten <=4pt] (p1v11) to [bend left=45] (p2v3);
    \draw [{stealth}-,connector,shorten >=4pt,shorten <=4pt] (p1v15) to [bend left=45] (p2v7);
    \draw [-{stealth},connector,shorten >=4pt,shorten <=4pt] (p1v8) to [bend right=45] (p2v0);
    \draw [{stealth}-,connector,shorten >=4pt,shorten <=4pt] (p1v12) to [bend right=45] (p2v4);

    % label processes
    \node (p1name) at (1.5,4.2) {Process 1};
    \node (p2name) at (6.5,4.2) {Process 2};
  \end{tikzpicture}
  \caption{}
  \label{fig:halos}
\end{figure}

% PETSc is scalable (cite?)
% PyOP2 (via Firedrake assembly) has good weak scalability

% also strong-scaling (but shown otherwise)
% key is to minimise amount of Python in the hot loops via judicious caching, persistent objects and expanded codegen

% use DG advection as an example - caching and persistent objects can be shown to be key
% but now things like halo exchanges for valid halos (i.e. noops) have non-trivial cost -> move out of Python to the generated code.

\vspace{1em}
