\section{Implementation}

% pyop3 is inspired by Simit in that we have a mesh representation that lowers to an indexed tensor 
% representation for computing

% should support Gpu, inter-element vectorisation

\subsection{Mesh operations}
% present the interface

\subsection{Hierarchical data layout}

\pyop3 employs a novel hierarchical data layout.
It was inspired by considering what the data layouts of mesh data actually look like.
As a simple example, consider the data layout for a typically unstructured mesh with *some nodes and some DoFs per node* (see Figure X - include a triangle too).

%In \pyop2, we flatten early to a DataSet == Set + dim
% can only guarantee fixed loop bounds for the innermost `dim` - for codegen.

% now show extruded - demos the need for a hierarchy as flattening clearly loses information.
% state that this lets us do cool composition?

% data layout example
\begin{tikzpicture}[y=-1cm]
  \fill[lightgray] (0,0) rectangle(7,1);
  \filldraw[draw=black, fill=white] (0.5,0) rectangle (1.5,1);
  \filldraw[draw=black, fill=white] (1.5,0) rectangle (2.5,1);
  \filldraw[draw=black, fill=white] (2.5,0) rectangle (3.5,1);
  \filldraw[draw=black, fill=white] (3.5,0) rectangle (4.5,1);
  \node[at={(1,.5)}, ptlabel] {$c_0$};
  \node[at={(2,.5)}, ptlabel] {$v_1$};
  \node[at={(3,.5)}, ptlabel] {$c_4$};
  \node[at={(4,.5)}, ptlabel] {$v_8$};
  \draw (0,0) -- (7,0);
  \draw (0,1) -- (7,1);

  \begin{scope}[yshift=-2cm]
    \filldraw[draw=black, fill=white] (2,0) rectangle (3,1);
    \filldraw[draw=black, fill=white] (3,0) rectangle (4,1);
    \node[at={(2.5,.5)}, ptlabel] {$d_0$};
    \node[at={(3.5,.5)}, ptlabel] {$d_1$};
    \draw (2,0) rectangle (4,1);

    \draw (2.5,-1) -- (2,0);
    \draw (3.5,-1) -- (4,0);
  \end{scope}

\end{tikzpicture}

\subsection{Parallel design}

% based on/lifted from PyOP2
% ghost/halo values for overlaps
% clever layout means we can exchange core, then owned, interleaving communication
% PETSc Mat for parallel matrices

% PETSc is scalable (cite?)
% PyOP2 (via Firedrake assembly) has good weak scalability

% also strong-scaling (but shown otherwise)
% key is to minimise amount of Python in the hot loops via judicious caching, persistent objects and expanded codegen

% use DG advection as an example - caching and persistent objects can be shown to be key
% but now things like halo exchanges for valid halos (i.e. noops) have non-trivial cost -> move out of Python to the generated code.

\vspace{1em}
