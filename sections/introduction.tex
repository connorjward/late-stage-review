\section{Introduction}

In scientific computing, the composition of appropriate software abstractions is essential for scientists to write portable and performant simulations in a productive way (the three P's).
Having suitable abstraction layers allows for a separation of concerns whereby numericists can reason about their problem from a purely mathematical point-of-view and computer scientists can focus on optimising performance.
Each discipline is presented with a particular interface from which the problems of interest can be expressed in the clearest possible way, facilitating rapid code development.

When it comes to writing software there are effectively three choices of approach.
For many problems, generic library interfaces introduce too much overhead to be viable options for writing programs.
Similarly, hand-written codes, though extremely fast, require a substantial effort to maintain and extend and the codebase can be very large.
Code generation is an appealing solution to these problems.
Given an appropriate abstraction, high-performance code can be automatically generated, compiled and run.
This offers an advantage over library interfaces because problem-specific information can be exploited to generate faster code (e.g. commonly used operations can be memoized for fast lookups), and the task of actually writing the code is offloaded to a compiler rather than being hand-written.
With a code generation framework, the key questions now become:
``What is an appropriate abstraction for capturing all of the behaviour I wish to model?", and
``What performance optimisations are nicely expressed at this layer of abstraction?"

% TODO: put in a list of some kind
In this work, we present \pyop3, a library for the fast execution of mesh-based computations over some local stencil.
In accordance with the principles described above, \pyop3 deals mainly in 3 abstractions:
Firstly, the user interface is motivated by the fact that many operations relating to the solution of \glspl{pde} can be expressed as the operation of some `local' kernel over a set of entities in the mesh where only functions with non-zero support on this entity are considered in the calculation.
A classic example of this sort of calculation occurs with finite element assembly where the cells of the mesh are the iteration set and the kernel uses \glspl{dof} from the cell and enclosing edges and vertices.
This first abstraction layer therefore presents an interface to the user where they may straightforwardly express the operation of local kernels within loops over mesh entities, specifying the requisite restrictions for the data.
The second abstraction, intended as an internal representation for the developer, describes the data layout and the third is a polyhedral loop model that is the target for the code generation.

The rest of this paper is laid out as follows:
In Section~\ref{sec:background} we review existing stencil libraries and mesh abstractions as well as strategies and details for code performance optimisation.
Section~\ref{sec:impl} discusses the design of \pyop3, Section~\ref{sec:future} then reviews some possible extensions that might be pursued in future.
Some concluding remarks are made in Section~\ref{sec:conclusions}.
